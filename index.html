<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Zouk Training Metronome</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f4f4f4;margin:0;padding:0;display:flex;justify-content:center;align-items:center;height:100vh;}
  .container{background:#fff;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1);padding:24px;width:320px;text-align:center;}
  h1{font-size:1.6rem;margin:0 0 12px;}
  .bpm-control{display:flex;align-items:center;justify-content:center;margin:12px 0;}
  .bpm-control input[type=number]{width:60px;margin-left:8px;text-align:center;}
  .bpm-control input[type=range]{width:200px;}
  .beat{font-size:4rem;color:#444;margin:12px 0;}
  button{background:#5900ad;color:#fff200;border:none;padding:10px 20px;border-radius:4px;font-size:2rem;cursor:pointer;font-family:Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;}
  button.stop{background:#0080bb;}
  button:focus{outline:none;}
</style>
</head>
<body>

<div class="container">
  <h1>Zouk Training Metronome</h1>

  <div class="bpm-control">
    <label for="bpm">BPM:</label>
    <input type="range" id="bpm" min="40" max="80" value="60">
    <input type="number" id="bpmNum" min="40" max="80" value="60">
  </div>

  <div class="bpm-control">
    <label for="dictSelect">Training:</label>
    <select id="dictSelect">
      <option value="colors" selected>Footwork</option>
      <option value="numbers">Head Motion</option>
      <option value="names">Insanity</option>
    </select>
  </div>

  <div class="bpm-control">
    <label for="speakMode">Speak Mode:</label>
    <input type="range" id="speakMode" min="1" max="3" step="1" value="1">
    <span id="speakModeLabel">Every 3rd Count</span>
  </div>

  <div class="beat" id="beatDisplay">1</div>
  <button id="toggleBtn">Zouk It!</button>
</div>

<script>
/* ───── GLOBALS & INITIALIZATION ──────── */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();

let isRunning = false;
let isStartPending = false;     // True when user clicked but waiting for speech unlock
let isSpeechInitialized = false; // True when the silent utterance completes

let bpm = 60;
let beat = 0;
let intervalId = null;
let currentOsc = null;

let speakMode = 1;
let speakOnThirdToggle = true;

let availableVoices = [];
let defaultVoice = null;

/* DOM Elements */
const bpmSlider = document.getElementById('bpm');
const bpmInput  = document.getElementById('bpmNum');
const beatDisp  = document.getElementById('beatDisplay');
const toggleBtn = document.getElementById('toggleBtn');
const dictSelect = document.getElementById('dictSelect');
const speakModeSlider = document.getElementById('speakMode');
const speakModeLabel = document.getElementById('speakModeLabel');


/* ───── 1️⃣  VOICE LOADING & SETUP ──────── */
function loadVoices() {
  availableVoices = window.speechSynthesis.getVoices();
  if (availableVoices.length === 0) {
    setTimeout(loadVoices, 200); // Retry for browsers (like Safari) with delayed voice loading
    return;
  }
  // Prefer English (US) voice
  const preferredLang = 'en-US';
  defaultVoice = availableVoices.find(v => v.lang.startsWith(preferredLang)) || availableVoices[0] || null;
}

loadVoices();
window.speechSynthesis.onvoiceschanged = loadVoices;


/* ───── 2️⃣  AUDIO CLICK GENERATOR ──────── */
function playClick(isFirstBeat) {
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = 'square';
  // Use current time for scheduling
  osc.frequency.setValueAtTime(isFirstBeat ? 1500 : 800, ctx.currentTime);
  gain.gain.setValueAtTime(0.3, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);

  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.05);

  currentOsc = osc;
}


/* ───── 3️⃣  PHRASE DICTIONARIES & PICKER ──────── */
const dictionaries = {
  colors: ["", "basic", "ladder all", "veeduh jeena", "veeduh jeena 1 80", "basic in place"],
  numbers: ["", "clockwise asynchronous", "clockwise synchronous", "counterclockwise synchronous", "counterclockwise asynchronous", "wiggle wiggle wiggle"],
  names: ["", "basic in place", "side basic", "linear basic", "pivot", "bonus", "boomerang", "hawool"]
};

let currentDict = "colors";
let phrases = dictionaries[currentDict];
let lastPhrase = null;

function pickPhrase() {
  const currentPhrases = dictionaries[currentDict];
  if (!currentPhrases.length) return "";
  let chosen;
  let attempt = 0;
  // Pick a phrase that is not the same as the last one
  do {
    chosen = currentPhrases[Math.floor(Math.random() * currentPhrases.length)];
    attempt++;
  } while (chosen === lastPhrase && attempt < 10);
  lastPhrase = chosen;
  return chosen;
}


/* ───── 4️⃣  SPEAK HELPER (Mobile Compatibility Core) ──────── */
function speak(text) {
  if (!('speechSynthesis' in window)) return;
  
  // This is the silent unlock call upon the user's first click
  const isUnlockAttempt = text === "" && !isSpeechInitialized;

  if (!isUnlockAttempt && !text) return; // Prevent speaking empty strings (except for the unlock)

  window.speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'en-US';
  utterance.rate = 1;
  utterance.pitch = 1;
  utterance.voice = defaultVoice; 

  utterance.onerror = (e) => {
    console.warn('SpeechSynthesisUtterance error:', e.error);
    // If the unlock attempt fails, flag it as initialized to allow the metronome to start anyway
    if (isUnlockAttempt) {
      isSpeechInitialized = true;
      if (isStartPending) startMetronome();
    }
  };
  
  // CRITICAL: This fires AFTER the speech engine has successfully opened and finished
  utterance.onend = () => {
    if (isUnlockAttempt) {
      isSpeechInitialized = true;
      console.log("Speech Engine UNLOCKED!");
      // If the user clicked to start while waiting, run the metronome now
      if (isStartPending) {
        isStartPending = false;
        startMetronome(); 
      }
    }
  };

  window.speechSynthesis.speak(utterance);
}


/* ───── 5️⃣  METRONOME LOGIC ──────── */
function startMetronome() {
  if (ctx.state === 'suspended') ctx.resume(); // Unlock Web Audio context

  isRunning = true;
  isStartPending = false; // Clear pending state
  beat = 0;
  beatDisp.textContent = '1';
  toggleBtn.textContent = 'Stop';
  toggleBtn.classList.add('stop');

  playClick(true); // first beat click (higher pitch)

  // Use the calculated time based on BPM for the interval
  const intervalTimeMs = 60000 / bpm; 

  intervalId = setInterval(() => {
    beat = (beat + 1) % 4;
    beatDisp.textContent = (beat + 1).toString();
    playClick(beat === 0); // higher pitch on beat 1

    if (beat === 2) { // third beat (where the phrase occurs)
      let shouldSpeak = false;

      // Logic for the Speak Mode setting
      if (speakMode === 1) {
        shouldSpeak = true;
      } else if (speakMode === 2) {
        speakOnThirdToggle = !speakOnThirdToggle;
        shouldSpeak = speakOnThirdToggle;
      } else if (speakMode === 3) {
        shouldSpeak = Math.random() < 0.25;
      }

      if (shouldSpeak) {
        const phrase = pickPhrase();
        speak(phrase);
      }
    }
  }, intervalTimeMs);
}

function stopMetronome() {
  isRunning = false;
  isStartPending = false; 

  if (intervalId) clearInterval(intervalId);
  intervalId = null;
  toggleBtn.textContent = 'Zouk It!';
  toggleBtn.classList.remove('stop');

  window.speechSynthesis.cancel();
  if (currentOsc) { currentOsc.stop(); currentOsc = null; }
}


/* ───── 6️⃣  EVENT HANDLERS ──────── */
// BPM Input Handlers
bpmSlider.addEventListener('input', (e) => {
  bpm = +e.target.value;
  bpmInput.value = bpm;
});
bpmInput.addEventListener('input', (e) => {
  let val = +e.target.value;
  if (val < 40) val = 40;
  if (val > 80) val = 80;
  bpm = val;
  bpmSlider.value = val;
});

// Dictionary change handler
dictSelect.addEventListener('change', (e) => {
  currentDict = e.target.value;
  phrases = dictionaries[currentDict]; // Update the phrases array
  lastPhrase = null; // reset to avoid immediate repeat
});

// Speak‑mode slider handler
function updateSpeakModeLabel() {
  const texts = {
    1: "Every 3rd Count",
    2: "Every Other 3rd Count",
    3: "Random (25 %)"
  };
  speakModeLabel.textContent = texts[speakMode] || "";
}
speakModeSlider.addEventListener('input', (e) => {
  speakMode = +e.target.value;
  updateSpeakModeLabel();
});
updateSpeakModeLabel(); // set initial label

// Main Start/Stop Toggle Button
toggleBtn.addEventListener('click', () => {
  if (isRunning || isStartPending) {
    stopMetronome();
  } else {
    // START path
    if (isSpeechInitialized || !('speechSynthesis' in window)) {
      // 1. Ready to go (Desktop or already unlocked on mobile)
      startMetronome();
    } else {
      // 2. Mobile/iOS: Needs unlock
      isStartPending = true; // Signal we want to start
      toggleBtn.textContent = 'Waiting...'; 
      // Call speak with an empty string to trigger the unlock. 
      // The 'onend' handler in speak() will call startMetronome() once ready.
      speak(""); 
    }
  }
});
</script>
</body>
</html>